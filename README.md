# TasksWG

Задание № 1          

Написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности,
но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.
                C/C++ example:

                bool isEven(int value){return value%2==0;}

Решение: 

                bool isEven(int value){return !(value & 1);}

                                
Задание № 2.             

Написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

Решение:

В директории Task_2 находятся два класса реализующих циклический буфер FIFO. Array_FIFO построен на основе массива. 

Плюсами данной реализации являются:

1. Быстрое добавление и удаление элементов в массив за O(1);

2. Высокая скорость обращения к данным, т.к. массив расположен в памяти последовательно, что позволяет использовать кэш-память;
  
Минусами:

1. При создании буффера большого размера память выделяется одним большим блоком;

List_FIFO построен на основе двусвязного списка.

Плюсами данной реализации являются:

1. При создании буффера большого размера память выделяется большим количеством небольших участков памяти, которые могут быть 
расположены в разных участках памяти;

Минусами:

1. В некоторых ситуациях необходимо пройти несколько элементов по списку, чтобы выставить указатель на нужную позицию;

2. Использование кэш-памяти затруднено;

Задание № 3. 

Написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Объяснить почему вы считаете, 
что функция соответствует заданным критериям.


Решение: 


Реализован алгоритм быстрой сортировки. Данный алгоритм был выбран мною, потому что он всегда работает с элементами массива 
расположенными последовательно и близко друг к другу, что позволяет использовать при обращении к данным элементам использовать 
кэш-память. Допустим, нужно сравнить элементы массива, длина которого 1000 элементов типа int. Такой массив занимает 
4 КБ и полностью помещается в кэше первого уровня размером 32 КБ. Система понимает, что вы начали работу с определённым куском 
оперативной памяти. Она копирует этот кусок в кэш, и процессор быстро выполняет действия над этим массивом. 
Потом изменённый массив из кэша копируется назад в оперативную память. Т.к. время доступа к кэш-памяти составляет в среднем 4 тика,
а оперативной памяти 200, то можно сделать вывод, что сортировка которая может использовать данное преимущество в скорости работы с 
данным в кэш-памяти будет превосходить с точки зрения процессорных тиков все остальные сортировки.



